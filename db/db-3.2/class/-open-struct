type=class
superclass=Object
included=
extended=
dynamically_included=
dynamically_extended=
library=ostruct
aliases=
aliasof=
source_location=refm/api/src/ostruct.rd:3

要素を動的に追加・削除できる手軽な構造体を提供するクラスです。

OpenStruct のインスタンスに対して未定義なメソッド x= を呼ぶと、
OpenStruct クラスの [[m:BasicObject#method_missing]] で捕捉され、そのインスタンスに
インスタンスメソッド x, x= が定義されます。
この挙動によって要素を動的に変更できる構造体として働きます。

  require 'ostruct'
  ab = OpenStruct.new
  ab.foo = 25
  p ab.foo          # => 25
  ab.bar = 2
  p ab.bar          # => 2
  p ab              # => <OpenStruct foo=25, bar=2>
  ab.delete_field("foo")
  p ab.foo          # => nil
  p ab              # => <OpenStruct bar=2>

初期化にハッシュを使用することもできます。

  require 'ostruct'
  son = OpenStruct.new({ :name => "Thomas", :age => 3 })
  p son.name        # => "Thomas"
  p son.age         # => 3
  son.age += 1
  p son.age         # => 4
  son.items = ["candy","toy"]
  p son.items       # => ["candy","toy"]
  p son             # => #<OpenStruct name="Thomas", age=4, items=["candy", "toy"]>

===[a:caveats] 注意事項

OpenStruct は Ruby のメソッド探索を利用して、プロパティに必要なメソッドを見つけて定義します。これは [[m:BasicObject#method_missing]] と [[m:BasicObject#define_singleton_method]] によって実現されます。

作成されるオブジェクトのパフォーマンスに懸念がある場合は、この点を考慮する必要があります。[[c:Hash]] や [[c:Struct]] を使用する場合と比較して、これらのプロパティの設定にははるかに多くのオーバーヘッドがあるためです。小規模な [[c:Hash]] から [[c:OpenStruct]] を作成し、いくつかの要素にアクセスした場合、直接ハッシュテーブルにアクセスするよりも 200 倍遅くなることがあります。

これは潜在的なセキュリティ問題です。信頼されていないユーザーデータ（例：JSON を用いたリクエスト）から [[c:OpenStruct]] を構築した場合、キーがメソッドを作成し、そのメソッド名が永久に GC されることがないため、DoS 攻撃を受ける可能性があります。

これは、Ruby バージョン間の非互換性の原因にもなります：

  o = OpenStruct.new
  o.then            # => Ruby < 2.6 では nil、Ruby >= 2.6 では Enumerator

以下の方法では、組み込みライブラリのメソッドが上書きされる可能性があり、バグやセキュリティ上の問題が発生する可能性があります：

  o = OpenStruct.new
  o.methods         # => [:to_h, :marshal_load, :marshal_dump, :each_pair, ...]
  o.methods = [:foo, :bar]
  o.methods         # => [:foo, :bar]

衝突を避けるために [[c:OpenStruct]] は ! で終わるメソッドは protected と private でのみ使用し、public な組み込みライブラリの ! で終わるメソッドはエイリアスを定義しています：

  o = OpenStruct.new(make: 'Bentley', class: :luxury)
  o.class           # => :luxury
  o.class!          # => OpenStruct

! で終わるフィールドは使用しないことが推奨されます（ただし、強制ではありません）。サブクラスのメソッドを上書きすることはできませんし、! で終わる OpenStruct 自身のメソッドを上書きすることもできません。

以上の理由から OpenStruct を一切使用しないことを検討してください。
